# 类型参数

## 一. 类型变量界定

- 类型变量界定是指在泛型的基础上，对泛型的范围进行进一步界定，从而缩下泛型的具体范围

- 使用 <: 指定泛型的具体范围

- 类型变量可以对方法和类中的泛型进行范围界定，这种界定建立在类继承层次结构的基础上

代码：

```scala
package generic_and_annotation

/**
  * 常用注解
  */
abstract class Father {
  // native 用于标记 cplusplusMethod 为 c/c++ 中实现的本地方法
  @native def cplusplusMethod()

}

// 标记 B 可被序列化，声明序列化版本
@SerialVersionUID(1000330L)
class Son extends Father with Serializable {
  // volatile 标记 name 非线程安全
  @volatile var name: String = "B"

  // transient 标记 age 不被序列化
  @transient var age: Int = 24

}
```

运行结果：

```
B
Person(Mary,24)
```

## 二. 视图界定

- 如果希望跨越类继承层次结构，可以使用视图界定来实现

- 视图界定实现的原理是隐式转换

- 视图界定通过符号 <% 来实现

代码：

```scala
package type_parameter

/**
  * 视图界定
  */

// <% 表示 S 可以是 Comparable 类继承层次结构中的类，也可以是经过隐式转换得到的类，该类实现了 Comparable 接口
case class Teacher[T, S <% Comparable[S]](var name: T, var height: S)

object ViewBound extends App {
  val t1 = Teacher("Bob", "34")

  // Int 类型此时会隐式转换为 RichInt 类型，而 RichInt 类属于 Comparable 继承层次结构
  val t2 = Teacher("Alice", 40)

}
```

## 三. 上界与下界

- 上界: <: 类型变量界定

- 下界: >: 下界的作用主要是保证类型安全



## 四. 上下文界定

### 1. Java 中的 Comparator 和 Comparable 接口

- Java 中的 Comparator 是一个外部比较器， Comparable 是一个内部比较器

代码1：

```java
package type_parameter;

/**
 * Java Employee 类
 */
public class Employee {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    Employee(String name) {
        this.name = name;
    }
}

package type_parameter;

import java.util.Comparator;

/**
 * Comparator 外部比较器
 */
public class EmployeeComparator implements Comparator<Employee> {

    @Override
    public int compare(Employee o1, Employee o2) {
        if(o1.getName().equalsIgnoreCase(o2.getName())) {
            return 1;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        EmployeeComparator ec = new EmployeeComparator();
        Employee e1 = new Employee("Alice");
        Employee e2 = new Employee("Mary");

        // 通过外部对象进行方法调用
        if(ec.compare(e1, e2) > 0) {
            System.out.println("两者姓名相同");
        } else {
            System.out.println("两者姓名不同");
        }

    }
}
```

代码2:

```java
package type_parameter;

/**
 * Java Employer 类
 */
public class Employer implements Comparable<Employer> {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    Employer(String name) {
        this.name = name;
    }

    @Override
    public int compareTo(Employer o) {
        if(this.getName().equalsIgnoreCase(o.getName())) {
            return 1;
        } else {
            return -1;
        }
    }
}


package type_parameter;

/**
 * Comparable 内部比较器
 */
public class EmployerComparable {
    public static void main(String[] args) {
        Employer e1 = new Employer("Alice");
        Employer e2 = new Employer("Mary");

        if(e1.compareTo(e2) > 0 ) {
            System.out.println("两者姓名相同");
        } else {
            System.out.println("两者姓名不同");
        }
    }
}
```

### 2. Scala 中的 Ordering 和 Ordered 特征（Trait)

- Ordering 混入了 Java 中的 Comparator 接口， Ordered 混入了 Java 中的 Comparable 接口

代码1:

```scala
package type_parameter

/**
  * Scala Ordered 使用
  */
case class Pet(val name: String) extends Ordered[Pet] {
  override def compare(that: Pet): Int = {
    if(this.name == that.name) {
      return 1
    } else {
      return -1
    }
  }
}

class Pair1[T <: Ordered[T]](val first: T, val second: T) {
  def smaller() = {
    if (first < second)
      first
    else
      second
  }
}

object OrderedViewBound extends App {
  val p = new Pair1(Pet("Dog"), Pet("Cat"))
  println(p.smaller())
  println(Pet("Dog").compare(Pet("Cat")))
}
```

运行结果:

```
Pet(Dog)
-1
```

