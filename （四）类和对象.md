# 类和对象

## 一. 类定义 对象创建

- 在类中定义公有成员时，scala 会默认生成公有的 getter setter 方法

- 定义私有成员，其 getter setter 方法也是私有的， 直接能访问的是我们自己定义的 getter setter 方法

- val变量对应的是java中的final类型变量，只生成了getter方法

- 如果将成员域定义为private[this]，则不会生成getter、setter方法

- 统一访问原则：调用者并不需要知道其通过方法还是字段访问来进行操作的

- 如果也需要程序自动会生成getter方法和setter方法，则需要引入 scala.reflect.BeanProperty 
然后采用注解的方式修饰变量

## 二. 类主构造器

- 类定义时不带参数时生成无参主构建器

- 主构造器的定义与类的定义交织在一直，将构造器参数直接放在类名称之后，主构建器还可以使用默认参数，主构造器中的参数还可以加访问控制符

- 主构造器会执行类定义中的所有语句,可以将初始化语句放在类体中，同样也可以在类中添加或重写相关方法

- 当主构造器的参数不用var或val修饰的时候，参数会生成类的私有（private[this]）val成员，并且不会产生getter和setter方法. 值得注意的是，如果在类中无任何地方使用了主构造器的参数，此时主构造器参数不会生成类成员

- 在某些情况下，可能需要禁用主构建器，类名后面紧跟 private 关键字可以将主构建器设为私有，不允许外部使用

代码：

```scala
package class_and_object

/**
  * 不但定义了一个类Person，还定义了主构造器，主构造器的参数为String、Int类型
  * @param name
  * @param age
  */

class Person (var name: String, var age: Int) {

  // println将作为主构建器中的一部分，在创建对象时被执行
  println("Constructing Person ...")

  // 重写 toString 方法
  override def toString: String = name + ": " + age

}

object Test {
  def main(args: Array[String]): Unit = {
    val p = new Person("Mary", 24)

    println("name = " + p.name)
    println("调用 toString 方法：" + p.toString)
    p.age = 21
    println("new age = " + p.age)

  }
}
```

## 三. 辅助构造函数

- 如果禁用了主构造器，则必须使用辅助构造函数来创建对象

- 辅助构造器的名称为 this

- 调用辅助构造函数时，必须先调用主构造函数或其他已经定义好的构造函数

代码1：

```scala
package class_and_object

/**
  * 只有辅助构造函数的类
  * 在定义辅助构造函数时，需要注意构造函数的顺序
  */
class Student {
  // 类成员
  private var name: String = null
  private var age: Int = 18
  private var sex: Int = 0

  // 辅助构造器 名字为 this
  def this(name: String){
    this()
    this.name = name
  }

  def this(name: String, age: Int) {
    this(name)
    this.age = age
  }

  def this(name: String, age: Int, sex: Int) {
    this(name, age)
    this.sex = sex
  }

}
```

代码2:

```scala
package class_and_object

/**
  * 带主构造函数、辅助构造函数的类
  */
class Employee(var name:String, var age: Int) {
  // 类成员
  private var sex: Int = 0

  // 辅助构造器
  def this(name: String, age:Int, sex: Int) {
    this(name, age)
    this.sex = sex
  }
  
}
```

## 四. 单例对象

- 在某些应用场景下，可能不需要创建对象，而是想直接调用方法，但是 Scala 语言并不支持 static 成员， Scala 通过单例对象来解决该问题. 

- 单例对象的使用方式同 Java 语言引用静态成员是一样的

单例对象创建方式：

```scala
package class_and_object

object StudentObject {

  private var studentNo: Int = 0;

  def uniqueStudentNo() = {
    studentNo += 1
    studentNo
  }

  def main(args: Array[String]): Unit = {
    println(StudentObject.uniqueStudentNo())
  }

}
```

运行结果：

	1

## 五. 伴生对象与伴生类

- 其实伴生对象和伴生类本质上是两个不同的类，只不过伴生对象和伴生类之间可以互相访问到对方的成员，包括私有成员

代码：


``` scala
package class_and_object

/**
  * 伴生对象和伴生类
  * 可以互相访问对方的成员包括私有成员
  *
  * @param name
  * @param age
  */
class StudentSample(var name: String, age: Int) {
  private var sex: Int = 0

  // 直接访问伴生对象的私有成员
  def printCompanionObject() = println(StudentSample.studentNo)
}

object StudentSample {

  private var studentNo: Int = 0;

  def uniqueStudentNo() = {
    studentNo += 1
    studentNo
  }

  def main(args: Array[String]): Unit = {
    println(StudentSample.uniqueStudentNo())
  }

}
```

## 六. apply 方法

- 利用 apply 方法可以直接利用类名创建对象

- apply 方法的实现机制仍然是 new 的方式，只不过在使用的时候可以省去 new 的操作

自己实现 apply 方法：

```scala
package class_and_object

/**
  * 伴生对象和伴生类
  * 可以互相访问对方的成员包括私有成员
  *
  * @param name
  * @param age
  */
class StudentSample(var name: String, var age: Int) {
  private var sex: Int = 0

  // 直接访问伴生对象的私有成员
  def printCompanionObject() = println(StudentSample.studentNo)
}

object StudentSample {

  private var studentNo: Int = 0;

  def uniqueStudentNo() = {
    studentNo += 1
    studentNo
  }

  // 定义自己的 apply 方法
  def apply(name: String, age: Int) = new StudentSample(name, age)


  def main(args: Array[String]): Unit = {
    println("studentNo = " + StudentSample.uniqueStudentNo())

    val s1 = new StudentSample("Mary", 24)
    // 直接访问伴生类中的私有成员
    println("sex = " + s1.sex)

    // 直接利用类名进行对象的创建
    val s2 = StudentSample("Mary", 24)
    println("name = " + s2.name)
    println("age = " + s2.age)

  }

}
```

运行结果：

	studentNo = 1
	sex = 0
	name = Mary
	age = 24

## 七. 抽象类

- 抽象类是一种不能被实例化的类， 抽象类中包含了若干不能完整定义的方法，这些方法由子类去扩展定义自己的实现

- 除抽象方法外，抽象类中还可以有抽象字段， 抽象类中定义的字段可以不用初始化

代码：

```scala
package class_and_object

/**
  * 抽象类
  */
abstract class Animal {
  var age: Int

  def eat: Unit

}

class Dog(var age: Int) extends Animal {

  // 注意这里可以不加 override 关键字
  def eat() = {
    println("Dog eat meat")
  }
}

// 通过扩展 App 创建程序的入口
object Dog extends App {
  new Dog(2).eat()
}
```

运行结果：

	Dog eat meat








 